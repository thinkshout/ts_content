<?php
/**
 * @file
 * ThinkShout Content migration classes.
 */

/**
 * Default migration settings
 */
abstract class TSContentMigration extends XMLMigration {
  /**
   * A Migration constructor takes an array of arguments as its first parameter.
   *
   * The arguments must be passed through to the parent constructor, unless
   * you're using a version of the Migrate module < 2.6.
   */
  public function __construct($arguments) {
    $this->arguments = $arguments;
    parent::__construct();

    // With migrate_ui enabled, migration pages will indicate people involved in
    // the particular migration, with their role and contact info. We default
    // the list in the shared class; it can be overridden for specific
    // migrations.
    // $this->team = array(
    //   new MigrateTeamMember('First Last', 'first.last@example.com', t('Developer')),
    // );

    $this->dependencies = $arguments['dependencies'];

    $this->addUnmigratedSources($arguments['unmigrated_sources']);
    $this->addUnmigratedDestinations($arguments['unmigrated_destinations']);
  }

  /**
   * Construct the machine name (for "drush ms" and other places).
   */
  protected function generateMachineName($class_name = NULL) {
    return $this->arguments['machine_name'];
  }

  /**
   * Custom method to create a source fields array.
   */
  protected function parseSourceFields(array $fields) {
    $source_fields = array();
    foreach ($fields as $field_settings) {
      if (isset($field_settings['source'])) {
        $source_fields[$field_settings['source']] = $field_settings['label'];
      }
    }
    return $source_fields;
  }

  /**
   * Creates custom field mapping for a migration XML document.
   *
   * @param array $fields
   *   An array of field data arrays.
   *
   * @return mixed
   *   The custom field mapping object.
   */
  protected function createCustomFieldMapping(array $fields) {
    foreach ($fields as $destination => $field_settings) {
      if (isset($field_settings['source'])) {
        $google_path = 'gsx:' . $field_settings['source'];
        $mapping = $this->addFieldMapping($destination, $field_settings['source'])
          ->xpath($google_path);
      }
      else {
        $mapping = $this->addFieldMapping($destination);
      }
      if (isset($field_settings['default_value'])) {
        $mapping->defaultValue($field_settings['default_value']);
      }
      if (isset($field_settings['source_migration'])) {
        $mapping->sourceMigration($field_settings['source_migration']);
      }
      if (isset($field_settings['arguments'])) {
        $mapping->arguments($field_settings['arguments']);
      }
      if (isset($field_settings['delimiter'])) {
        $mapping->separator($field_settings['delimiter']);
      }
      if (isset($field_settings['callbacks'])) {
        $mapping->callbacks($field_settings['callbacks']);
      }
    }

    if (isset($mapping)) {
      return $mapping;
    }
    else {
      return NULL;
    }
  }

  /**
   * Instantiates a migration source class.
   *
   * Override for each migration type.
   *
   * @param string $data_url
   *   The URL the migration retrieves data from.
   * @param array $fields
   *   The migration source fields.
   * @param array $extra_source_fields
   *   Migration source fields that don't belong in source data, usually because
   *   they're not user-editable.
   */
  protected abstract function createMigrationSource($data_url, $fields, $extra_source_fields = NULL);
}

/**
 * ThinkShout XML content migration class.
 *
 * Uses XML generated by Google Docs spreadsheets.
 */
abstract class TSXMLContentMigration extends TSContentMigration {
  /**
   * Constructor.
   *
   * {@inheritdoc}
   */
  public function __construct($arguments) {
    parent::__construct($arguments);
  }

  /**
   * Creates an XML migration source.
   *
   * @param string $data_url
   *   The URL the migration retrieves data from.
   * @param array $fields
   *   Migration source fields.
   * @param array $extra_source_fields
   *   Migration source fields that don't belong in source data, usually because
   *   they're not user-editable.
   */
  protected function createMigrationSource($data_url, $fields, $extra_source_fields = array()) {
    // Item xpath is elative to document in data_url.
    $item_xpath = '/feed/entry';
    // Item ID xpath is relative to item_xpath.
    $item_id_xpath = 'gsx:id';

    $source_fields = $this->parseSourceFields($fields);

    if (!empty($extra_source_fields)) {
      $source_fields = array_merge($source_fields, $extra_source_fields);
    }

    $this->source = new MigrateSourceXML($data_url, $item_xpath, $item_id_xpath, $source_fields);
  }
}

/**
 * Migrate Node content.
 */
class TSNodeMigration extends TSXMLContentMigration {
  /**
   * Constructor.
   *
   * {@inheritdoc}
   */
  public function __construct(array $arguments) {
    parent::__construct($arguments);

    $this->description = t('Nodes');

    // Map for the migration:
    // @TODO should be handled by merging in default values in the hook.
    if (!isset($arguments['map_source_key'])) {
      $arguments['map_source_key'] = array(
        'gsx:id' => array(
          'type' => 'int',
          'not null' => TRUE,
        ),
      );
    }

    $this->map = new MigrateSQLMap(
      $this->machineName,
      $arguments['map_source_key'],
      MigrateDestinationNode::getKeySchema()
    );

    // If provided, set some default options.
    $options = NULL;
    if (isset($arguments['destination_options'])) {
      $options = MigrateDestinationNode::options(
        $arguments['destination_options']['language'],
        $arguments['destination_options']['text_format']
      );
    }

    $this->createCustomFieldMapping($arguments['fields']);
    $this->createMigrationSource($arguments['data_url'], $arguments['fields']);

    $this->destination = new MigrateDestinationNode($arguments['type'], $options);
  }

  /**
   * Modify data before it is saved.
   */
  public function prepare($entity, $row) {
    // Workbench moderation default to published.
    // https://www.drupal.org/node/1452016
    if (module_exists('workbench_moderation')) {
      $entity->revision = FALSE;
      $entity->is_new = !(isset($entity->nid) && ($entity->nid));
      $entity->workbench_moderation_state_current = 'published';
      $entity->workbench_moderation_state_new = 'published';
    }

  }
}

/**
 * Migrate Menu Link content.
 */
class TSMenuLinkMigration extends TSXMLContentMigration {
  /**
   * Construct method.
   */
  public function __construct(array $arguments) {
    parent::__construct($arguments);

    $this->description = t('Menu Links');

    // Map for the migration:
    // @TODO should be handled by merging in default values in the hook.
    if (!isset($arguments['map_source_key'])) {
      $arguments['map_source_key'] = array(
        'id' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
      );
    }

    $this->map = new MigrateSQLMap(
      $this->machineName,
      $arguments['map_source_key'],
      MigrateDestinationMenuLinks::getKeySchema()
    );

    $this->createCustomFieldMapping($arguments['fields']);
    $this->createMigrationSource($arguments['data_url'], $arguments['fields']);

    $this->destination = new MigrateDestinationMenuLinksWithAttributes();
  }

  /**
   * Modify data before it is saved.
   */
  public function prepare($entity, stdClass $row) {
    // Convert the alias to the node path.
    $node_path = drupal_lookup_path('source', $row->path);
    if ($node_path == FALSE) {
      // If node path not found, assume external.
      $node_path = $row->path;
      $row->external = 1;
    }

    $row->path = $node_path;
    // May only need to set $entity path value.
    $entity->link_path = $node_path;

    $attributes = array();

    // Add attributes into options field.
    if (!empty($entity->attribute_id)) {
      $attributes['id'] = $entity->attribute_id;
    }
    if (!empty($entity->attribute_name)) {
      $attributes['name'] = $entity->attribute_name;
    }
    if (!empty($entity->attribute_target)) {
      $attributes['target'] = $entity->attribute_target;
    }
    if (!empty($entity->attribute_rel)) {
      $attributes['rel'] = $entity->attribute_rel;
    }
    if (!empty($entity->attribute_class)) {
      $attributes['class'] = $entity->attribute_class;
    }
    if (!empty($entity->attribute_style)) {
      $attributes['style'] = $entity->attribute_style;
    }
    if (!empty($entity->attribute_accesskey)) {
      $attributes['accesskey'] = $entity->attribute_accesskey;
    }

    if (!empty($attributes)) {
      $options = array(
        'attributes' => $attributes,
      );
      $entity->options = $options;
    }
  }

  /**
   * Create stubs for content that has not yet been migrated.
   */
  protected function createStub($migration) {
    // If refparent is 0, that means it has no parent, so don't create a stub.
    if (!$migration->sourceValues->refparent) {
      return FALSE;
    }
    $menu_link = array(
      'menu_name' => $migration->sourceValues->menu_name,
      'link_path' => 'stub-path',
      'router_path' => 'stub-path',
      'link_title' => t('Stub title'),
    );
    $id = menu_link_save($menu_link);
    if ($id) {
      return array($id);
    }
    else {
      return FALSE;
    }
  }
}

/**
 * Migrate Bean content.
 */
class TSBeanMigration extends TSXMLContentMigration {
  /**
   * Constructor.
   *
   * {@inheritdoc}
   */
  public function __construct(array $arguments) {
    parent::__construct($arguments);

    $this->description = t('Beans');

    // Map for the migration:
    // @TODO should be handled by merging in default values in the hook.
    if (!isset($arguments['map_source_key'])) {
      $arguments['map_source_key'] = array(
        'id' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
      );
    }

    $this->map = new MigrateSQLMap(
      $this->machineName,
      $arguments['map_source_key'],
      MigrateDestinationBean::getKeySchema('bean')
    );

    $this->createCustomFieldMapping($arguments['fields']);

    // TODO: This needs to be moved into each bean record.
    $this->addFieldMapping('type')->defaultValue($arguments['type']);

    $this->createMigrationSource($arguments['data_url'], $arguments['fields'], array('data'));

    $this->destination = new MigrateDestinationBean('bean', $arguments['type']);
  }

  /**
   * Modify data before it is saved.
   */
  public function prepare($node, stdClass $row) {
    $node->data = array(
      'view_mode' => $node->view_mode,
    );

    if ($node->type == 'marquee') {
      $node->data['slider_settings'] = array(
        'slideshow_speed' => '3',
        'animation_duration' => '.5',
      );
    }
  }
}

/**
 * Migrate User content
 * @todo: Populate this class.
 */
class TSUserMigration extends TSXMLContentMigration {
  /**
   * Constructor.
   *
   * {@inheritdoc}
   */
  public function __construct(array $arguments) {
    parent::__construct($arguments);
  }
}

/**
 * Migrate Taxonomy Term content
 */
class TSTermMigration extends TSXMLContentMigration {
  /**
   * Constructor.
   *
   * {@inheritdoc}
   */
  public function __construct(array $arguments) {
    parent::__construct($arguments);

    $this->description = t('Taxonomy Terms');

    // Map for the migration:
    $this->map = new MigrateSQLMap($this->machineName,
      array(
        'id' => array(
          'type' => 'int',
          'not null' => TRUE,
        ),
      ),
      MigrateDestinationTerm::getKeySchema()
    );

    $this->createCustomFieldMapping($arguments['fields']);
    $this->createMigrationSource($arguments['data_url'], $arguments['fields']);

    $this->destination = new MigrateDestinationTerm($arguments['vocabulary_name']);
  }
}

/**
 * Migrate Field Collection content
 */
class TSFieldCollectionMigration extends TSXMLContentMigration {
  /**
   * Constructor.
   *
   * {@inheritdoc}
   */
  public function __construct(array $arguments) {
    parent::__construct($arguments);

    $this->description = t('Field Collections');

    if (module_exists('field_collection')) {
      // Map for the migration.
      $this->map = new MigrateSQLMap($this->machineName,
        array(
          'id' => array(
            'type' => 'int',
            'not null' => TRUE,
          ),
        ),
        MigrateDestinationFieldCollection::getKeySchema()
      );

      $this->createCustomFieldMapping($arguments['fields']);
      $this->createMigrationSource($arguments['data_url'], $arguments['fields']);

      $this->destination = new MigrateDestinationFieldCollection($arguments['type'], array('host_entity_type' => 'bean'));
    }
  }
}
